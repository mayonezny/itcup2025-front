/******************************************************************************
 * This file was generated by langium-cli 4.1.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable */
import * as langium from 'langium';

export const fraudRulesTerminals = {
    AND: /AND/,
    OR: /OR/,
    NOT: /NOT/,
    BETWEEN: /BETWEEN/,
    Ident: /[A-Z][A-Z0-9_]*/,
    TIME: /(0\d|1\d|2[0-3]):[0-5]\d:[0-5]\d/,
    NUMBER: /\d+(\.\d+)?/,
    GE: />=/,
    GT: />/,
    LE: /<=/,
    LT: /</,
    EQ: /=/,
    WS: /\s+/,
};

export type fraudRulesTerminalNames = keyof typeof fraudRulesTerminals;

export type fraudRulesKeywordNames =
    | "("
    | ")"
    | ","
    | "["
    | "]";

export type fraudRulesTokenNames = fraudRulesTerminalNames | fraudRulesKeywordNames;

/* сравнения */
export type CmpOp = string;

export function isCmpOp(item: unknown): item is CmpOp {
    return (typeof item === 'string' && (/>=/.test(item) || />/.test(item) || /<=/.test(item) || /</.test(item) || /=/.test(item)));
}

/* AND – средний */
export interface Conjunction extends langium.AstNode {
    readonly $container: Disjunction | Primary;
    readonly $type: 'Conjunction';
    terms: Array<Primary>;
}

export const Conjunction = {
    $type: 'Conjunction',
    terms: 'terms'
} as const;

export function isConjunction(item: unknown): item is Conjunction {
    return reflection.isInstance(item, Conjunction.$type);
}

/* OR имеет наименьший приоритет */
export interface Disjunction extends langium.AstNode {
    readonly $container: Model;
    readonly $type: 'Disjunction';
    groups: Array<Conjunction>;
}

export const Disjunction = {
    $type: 'Disjunction',
    groups: 'groups'
} as const;

export function isDisjunction(item: unknown): item is Disjunction {
    return reflection.isInstance(item, Disjunction.$type);
}

export interface Model extends langium.AstNode {
    readonly $type: 'Model';
    expression: Disjunction;
}

export const Model = {
    $type: 'Model',
    expression: 'expression'
} as const;

export function isModel(item: unknown): item is Model {
    return reflection.isInstance(item, Model.$type);
}

/* Предикат: IDENT (CmpOp Value) | (NOT? BETWEEN [Value, Value]) */
export interface Predicate extends langium.AstNode {
    readonly $container: Primary;
    readonly $type: 'Predicate';
    a?: Value;
    b?: Value;
    name?: string;
    neg: boolean;
    op?: CmpOp;
    value?: Value;
}

export const Predicate = {
    $type: 'Predicate',
    a: 'a',
    b: 'b',
    name: 'name',
    neg: 'neg',
    op: 'op',
    value: 'value'
} as const;

export function isPredicate(item: unknown): item is Predicate {
    return reflection.isInstance(item, Predicate.$type);
}

/* NOT – самый высокий */
export interface Primary extends langium.AstNode {
    readonly $container: Conjunction;
    readonly $type: 'Primary';
    atom?: Predicate;
    inner?: Conjunction;
    nots: Array<string>;
}

export const Primary = {
    $type: 'Primary',
    atom: 'atom',
    inner: 'inner',
    nots: 'nots'
} as const;

export function isPrimary(item: unknown): item is Primary {
    return reflection.isInstance(item, Primary.$type);
}

/* --- Data type rule: значение как строка --- */
export type Value = string;

export function isValue(item: unknown): item is Value {
    return (typeof item === 'string' && (/(0\d|1\d|2[0-3]):[0-5]\d:[0-5]\d/.test(item) || /\d+(\.\d+)?/.test(item)));
}

export type fraudRulesAstType = {
    Conjunction: Conjunction
    Disjunction: Disjunction
    Model: Model
    Predicate: Predicate
    Primary: Primary
}

export class fraudRulesAstReflection extends langium.AbstractAstReflection {
    override readonly types = {
        Conjunction: {
            name: Conjunction.$type,
            properties: {
                terms: {
                    name: Conjunction.terms,
                    defaultValue: []
                }
            },
            superTypes: []
        },
        Disjunction: {
            name: Disjunction.$type,
            properties: {
                groups: {
                    name: Disjunction.groups,
                    defaultValue: []
                }
            },
            superTypes: []
        },
        Model: {
            name: Model.$type,
            properties: {
                expression: {
                    name: Model.expression
                }
            },
            superTypes: []
        },
        Predicate: {
            name: Predicate.$type,
            properties: {
                a: {
                    name: Predicate.a
                },
                b: {
                    name: Predicate.b
                },
                name: {
                    name: Predicate.name
                },
                neg: {
                    name: Predicate.neg,
                    defaultValue: false
                },
                op: {
                    name: Predicate.op
                },
                value: {
                    name: Predicate.value
                }
            },
            superTypes: []
        },
        Primary: {
            name: Primary.$type,
            properties: {
                atom: {
                    name: Primary.atom
                },
                inner: {
                    name: Primary.inner
                },
                nots: {
                    name: Primary.nots,
                    defaultValue: []
                }
            },
            superTypes: []
        }
    } as const satisfies langium.AstMetaData
}

export const reflection = new fraudRulesAstReflection();
